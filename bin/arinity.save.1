#!/usr/bin/perl
# Copyright (c) 2012 Ethrik Development Group
# see doc/LICENSE for license information.

use warnings;
use strict;
use 5.010;

# Set our program name.
local $0 = 'arinity';
our $VERSION = '0.1-dev';

# Parse options and find running directory
our (%opts, $run_dir);
BEGIN {
    for (@ARGV) {
        # --key=value argument
        when (/--(.+?)=(.+)/) { $opts{$1} = $2 }

        # -letter (-l) argument
        when (/-(.{1})/) { $opts{flags}{$1} = 1 }
    }

    # No directory
    $run_dir = $opts{dir};
    if (!$run_dir) {
        die 'No running directory specified. Run Arinity from its start script';
    }
    die 'Can\'t enter run directory' unless chdir $run_dir;

    use lib 'lib';
}

# Dependencies
use IO::Async;
use IO::Async::Stream;
use IO::Socket::IP;

# Core packages
use API;
use IRC;
use Conf;
use Database;
use EventedObject;
use Logger;
use Utils;

# Global variables.
our ($loop, $logger, $database, $conf, $proto, $stream, $me, $DEBUG, $PID);

boot();

sub boot {
    &setup_logger;
    &setup_conf;
    &setup_db;
    &setup_loop;
    &handle_opts;
    &setup_irc;
    &API::load_config;
    &setup_link;

    # Parse database.
    $database->parse or $logger->log(FATAL => 'Failed to parse database.');

    # Become a daemon.
    &become_daemon;

    # Enter main loop.
    $loop->loop_forever;
}

sub setup_logger {
    # Initialize Logger
    $logger = Logger->new;

    # Add hook for fatal errors.
    $logger->on(LOG_FATAL => sub {
        die "FATAL ERROR: $_[0]\n";
    }, 'core.fatal');
}

sub setup_conf {
    my $file ||= 'etc/arinity.conf';
    $file = $opts{config} if $opts{config};

    $conf = Conf->new($file);

    # hook to 'load' function to tell API.pm which modules to load immediately.
    $conf->on(function_load => sub {
        my $name = $_[2];
        push @API::load_conf, $name;
        $API::proto_mod = $name if $name =~ m|^proto/|;
    }, 'conf.function.load');

    $conf->parse or $logger->log(FATAL => 'Failed to parse configuration.');
}

sub setup_db {
    # Setup our database, but don't parse it until later.
    $database = Database->new('etc/services.db');
}

sub setup_loop {
    # Setup IO::Async.
    if ($loop = $conf->get('main:loop')) {
        $loop = eval {
            require 'IO/Async/Loop/'.ucfirst($loop).'.pm';
            ('IO::Async::Loop::'.ucfirst($loop))->new
        };
        $logger->log(FATAL => 'Specified \'loop\' options does not exist or is not installed on this system') if !$loop;
    }
    else {
        $logger->log(FATAL => 'No \'loop\' option specified. This is most definitely required');
    }
}

sub handle_opts {
    # DEBUG (d) flag.
    if ($opts{flags}{d}) {
        $DEBUG = 1;

        # add hook to print all logging to STDOUT.
        $logger->on(LOG_ALL => sub {
            say "DEBUG: $_[0]";
        }, 'core.debug');

        $logger->log(INFO => 'Running in debug mode.');
    }
}

sub setup_irc {
    $me = IRC->create_server(
        parent      => 0,
        name        => $conf->get('me:name'),
        id          => $conf->get('me:sid'),
        description => $conf->get('me:description')
    );
}

sub setup_link {

    # Check for required configuration values before continuing.
    foreach my $what (qw|link:host link:port|) {
	    if (!$conf->get($what)) {
		    $logger->log(FATAL => "Missing $what value in configuration. Please check your configuration file.");
	    }
    }

    # Create the socket.
    my $socket = IO::Socket::IP->new(
	    Proto    => 'tcp',
	    PeerAddr => $conf->get('link:host'),
	    PeerPort => $conf->get('link:port'),
	    Timeout  => 10
    ) or $logger->log(FATAL => 'Failed to connect to uplink.');
		
    # Create an IO::Async::Stream object based on the above socket.
    $stream = IO::Async::Stream->new(
        handle  => $socket,
        on_read => sub {
            my (undef, $buffref, $eof) = @_;
            while ($$buffref =~ s/^(.*)\n//) {
                $logger->log(DEBUG => ">> $1");
                $proto->fire(sock_got_line => $1);
            }
        }
    );

    # Add the stream to the loop.
    $loop->add($stream);

    # Send buffered data.
    if ($proto->{temp_buffer}) {
        $logger->log(DEBUG => 'Sending buffered data');
        $proto->send($_) foreach @{delete $proto->{temp_buffer}};
    }

    # Tell the protocol module that the socket is ready.
    $proto->fire('sock_connect');
}

sub become_daemon {
    unless ($DEBUG) {
        open STDIN, '<', '/dev/null' or $logger->log(FATAL => "Can't read /dev/null: $!");
        open STDOUT, '>', '/dev/null' or $logger->log(FATAL => "Can't write to /dev/null: $!");
        open STDERR, '>', '/dev/null' or $logger->log(FATAL => "Can't write to /dev/null: $!");

        # Write pid.
        open my $pidfh, '>', 'etc/arinity.pid' or $logger->log(FATAL => 'Can\'t write to etc/arinity.pid');
        $PID = fork;
        say $pidfh $PID if $PID;
        close $pidfh;
    }

    exit if $PID;
    $PID = $$;
    POSIX::setsid();
}

# vim: set ai et sw=4 ts=4:
